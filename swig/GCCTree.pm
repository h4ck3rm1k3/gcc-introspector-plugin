# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package GCCTree;
use base qw(Exporter);
use base qw(DynaLoader);
package GCCTreec;
bootstrap GCCTree;
package GCCTree;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package GCCTree;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package GCCTree;

*_obstack_newchunk = *GCCTreec::_obstack_newchunk;
*_obstack_free = *GCCTreec::_obstack_free;
*_obstack_begin = *GCCTreec::_obstack_begin;
*_obstack_begin_1 = *GCCTreec::_obstack_begin_1;
*_obstack_memory_used = *GCCTreec::_obstack_memory_used;
*obstack_init = *GCCTreec::obstack_init;
*obstack_alloc = *GCCTreec::obstack_alloc;
*obstack_copy = *GCCTreec::obstack_copy;
*obstack_copy0 = *GCCTreec::obstack_copy0;
*obstack_free = *GCCTreec::obstack_free;
*obstack_blank = *GCCTreec::obstack_blank;
*obstack_grow = *GCCTreec::obstack_grow;
*obstack_grow0 = *GCCTreec::obstack_grow0;
*obstack_1grow = *GCCTreec::obstack_1grow;
*obstack_ptr_grow = *GCCTreec::obstack_ptr_grow;
*obstack_int_grow = *GCCTreec::obstack_int_grow;
*obstack_finish = *GCCTreec::obstack_finish;
*obstack_object_size = *GCCTreec::obstack_object_size;
*obstack_room = *GCCTreec::obstack_room;
*obstack_make_room = *GCCTreec::obstack_make_room;
*obstack_1grow_fast = *GCCTreec::obstack_1grow_fast;
*obstack_ptr_grow_fast = *GCCTreec::obstack_ptr_grow_fast;
*obstack_int_grow_fast = *GCCTreec::obstack_int_grow_fast;
*obstack_blank_fast = *GCCTreec::obstack_blank_fast;
*obstack_base = *GCCTreec::obstack_base;
*obstack_next_free = *GCCTreec::obstack_next_free;
*obstack_alignment_mask = *GCCTreec::obstack_alignment_mask;
*obstack_chunk_size = *GCCTreec::obstack_chunk_size;
*obstack_memory_used = *GCCTreec::obstack_memory_used;
*ht_create = *GCCTreec::ht_create;
*ht_destroy = *GCCTreec::ht_destroy;
*ht_lookup = *GCCTreec::ht_lookup;
*ht_lookup_with_hash = *GCCTreec::ht_lookup_with_hash;
*ht_forall = *GCCTreec::ht_forall;
*ht_purge = *GCCTreec::ht_purge;
*ht_load = *GCCTreec::ht_load;
*ht_dump_statistics = *GCCTreec::ht_dump_statistics;
*VEC_constructor_elt_base_length = *GCCTreec::VEC_constructor_elt_base_length;
*VEC_constructor_elt_base_last = *GCCTreec::VEC_constructor_elt_base_last;
*VEC_constructor_elt_base_index = *GCCTreec::VEC_constructor_elt_base_index;
*VEC_constructor_elt_base_iterate = *GCCTreec::VEC_constructor_elt_base_iterate;
*VEC_constructor_elt_base_embedded_size = *GCCTreec::VEC_constructor_elt_base_embedded_size;
*VEC_constructor_elt_base_embedded_init = *GCCTreec::VEC_constructor_elt_base_embedded_init;
*VEC_constructor_elt_base_space = *GCCTreec::VEC_constructor_elt_base_space;
*VEC_constructor_elt_base_splice = *GCCTreec::VEC_constructor_elt_base_splice;
*VEC_constructor_elt_base_quick_push = *GCCTreec::VEC_constructor_elt_base_quick_push;
*VEC_constructor_elt_base_pop = *GCCTreec::VEC_constructor_elt_base_pop;
*VEC_constructor_elt_base_truncate = *GCCTreec::VEC_constructor_elt_base_truncate;
*VEC_constructor_elt_base_replace = *GCCTreec::VEC_constructor_elt_base_replace;
*VEC_constructor_elt_base_quick_insert = *GCCTreec::VEC_constructor_elt_base_quick_insert;
*VEC_constructor_elt_base_ordered_remove = *GCCTreec::VEC_constructor_elt_base_ordered_remove;
*VEC_constructor_elt_base_unordered_remove = *GCCTreec::VEC_constructor_elt_base_unordered_remove;
*VEC_constructor_elt_base_block_remove = *GCCTreec::VEC_constructor_elt_base_block_remove;
*VEC_constructor_elt_base_address = *GCCTreec::VEC_constructor_elt_base_address;
*VEC_constructor_elt_base_lower_bound = *GCCTreec::VEC_constructor_elt_base_lower_bound;
*VEC_constructor_elt_gc_alloc = *GCCTreec::VEC_constructor_elt_gc_alloc;
*VEC_constructor_elt_gc_copy = *GCCTreec::VEC_constructor_elt_gc_copy;
*VEC_constructor_elt_gc_free = *GCCTreec::VEC_constructor_elt_gc_free;
*VEC_constructor_elt_gc_reserve = *GCCTreec::VEC_constructor_elt_gc_reserve;
*VEC_constructor_elt_gc_reserve_exact = *GCCTreec::VEC_constructor_elt_gc_reserve_exact;
*VEC_constructor_elt_gc_safe_grow = *GCCTreec::VEC_constructor_elt_gc_safe_grow;
*VEC_constructor_elt_gc_safe_grow_cleared = *GCCTreec::VEC_constructor_elt_gc_safe_grow_cleared;
*VEC_constructor_elt_gc_safe_splice = *GCCTreec::VEC_constructor_elt_gc_safe_splice;
*VEC_constructor_elt_gc_safe_push = *GCCTreec::VEC_constructor_elt_gc_safe_push;
*VEC_constructor_elt_gc_safe_insert = *GCCTreec::VEC_constructor_elt_gc_safe_insert;
*protected_set_expr_location = *GCCTreec::protected_set_expr_location;
*vector_type_mode = *GCCTreec::vector_type_mode;
*decl_value_expr_lookup = *GCCTreec::decl_value_expr_lookup;
*decl_value_expr_insert = *GCCTreec::decl_value_expr_insert;
*decl_debug_expr_lookup = *GCCTreec::decl_debug_expr_lookup;
*decl_debug_expr_insert = *GCCTreec::decl_debug_expr_insert;
*decl_init_priority_lookup = *GCCTreec::decl_init_priority_lookup;
*decl_fini_priority_lookup = *GCCTreec::decl_fini_priority_lookup;
*decl_init_priority_insert = *GCCTreec::decl_init_priority_insert;
*decl_fini_priority_insert = *GCCTreec::decl_fini_priority_insert;
*build_optimization_node = *GCCTreec::build_optimization_node;
*build_target_option_node = *GCCTreec::build_target_option_node;
*decl_assembler_name = *GCCTreec::decl_assembler_name;
*decl_assembler_name_equal = *GCCTreec::decl_assembler_name_equal;
*decl_assembler_name_hash = *GCCTreec::decl_assembler_name_hash;
*tree_size = *GCCTreec::tree_size;
*tree_code_size = *GCCTreec::tree_code_size;
*make_node_stat = *GCCTreec::make_node_stat;
*copy_node_stat = *GCCTreec::copy_node_stat;
*copy_list = *GCCTreec::copy_list;
*make_tree_binfo_stat = *GCCTreec::make_tree_binfo_stat;
*make_tree_vec_stat = *GCCTreec::make_tree_vec_stat;
*get_identifier = *GCCTreec::get_identifier;
*get_identifier_with_length = *GCCTreec::get_identifier_with_length;
*maybe_get_identifier = *GCCTreec::maybe_get_identifier;
*build_nt = *GCCTreec::build_nt;
*build_nt_call_vec = *GCCTreec::build_nt_call_vec;
*build0_stat = *GCCTreec::build0_stat;
*build1_stat = *GCCTreec::build1_stat;
*build2_stat = *GCCTreec::build2_stat;
*build3_stat = *GCCTreec::build3_stat;
*build4_stat = *GCCTreec::build4_stat;
*build5_stat = *GCCTreec::build5_stat;
*build6_stat = *GCCTreec::build6_stat;
*build1_stat_loc = *GCCTreec::build1_stat_loc;
*build2_stat_loc = *GCCTreec::build2_stat_loc;
*build3_stat_loc = *GCCTreec::build3_stat_loc;
*build4_stat_loc = *GCCTreec::build4_stat_loc;
*build5_stat_loc = *GCCTreec::build5_stat_loc;
*build6_stat_loc = *GCCTreec::build6_stat_loc;
*build_var_debug_value_stat = *GCCTreec::build_var_debug_value_stat;
*tree_to_double_int = *GCCTreec::tree_to_double_int;
*double_int_to_tree = *GCCTreec::double_int_to_tree;
*double_int_fits_to_tree_p = *GCCTreec::double_int_fits_to_tree_p;
*force_fit_type_double = *GCCTreec::force_fit_type_double;
*build_int_cstu = *GCCTreec::build_int_cstu;
*build_int_cst = *GCCTreec::build_int_cst;
*build_int_cst_type = *GCCTreec::build_int_cst_type;
*build_int_cst_wide = *GCCTreec::build_int_cst_wide;
*build_vector = *GCCTreec::build_vector;
*build_vector_from_ctor = *GCCTreec::build_vector_from_ctor;
*build_vector_from_val = *GCCTreec::build_vector_from_val;
*build_constructor = *GCCTreec::build_constructor;
*build_constructor_single = *GCCTreec::build_constructor_single;
*build_constructor_from_list = *GCCTreec::build_constructor_from_list;
*build_real_from_int_cst = *GCCTreec::build_real_from_int_cst;
*build_complex = *GCCTreec::build_complex;
*build_one_cst = *GCCTreec::build_one_cst;
*build_zero_cst = *GCCTreec::build_zero_cst;
*build_string = *GCCTreec::build_string;
*build_tree_list_stat = *GCCTreec::build_tree_list_stat;
*build_tree_list_vec_stat = *GCCTreec::build_tree_list_vec_stat;
*build_decl_stat = *GCCTreec::build_decl_stat;
*build_fn_decl = *GCCTreec::build_fn_decl;
*build_translation_unit_decl = *GCCTreec::build_translation_unit_decl;
*build_block = *GCCTreec::build_block;
*build_empty_stmt = *GCCTreec::build_empty_stmt;
*build_omp_clause = *GCCTreec::build_omp_clause;
*build_vl_exp_stat = *GCCTreec::build_vl_exp_stat;
*build_call_nary = *GCCTreec::build_call_nary;
*build_call_valist = *GCCTreec::build_call_valist;
*build_call_array_loc = *GCCTreec::build_call_array_loc;
*build_call_vec = *GCCTreec::build_call_vec;
*make_signed_type = *GCCTreec::make_signed_type;
*make_unsigned_type = *GCCTreec::make_unsigned_type;
*signed_or_unsigned_type_for = *GCCTreec::signed_or_unsigned_type_for;
*signed_type_for = *GCCTreec::signed_type_for;
*unsigned_type_for = *GCCTreec::unsigned_type_for;
*initialize_sizetypes = *GCCTreec::initialize_sizetypes;
*set_sizetype = *GCCTreec::set_sizetype;
*fixup_unsigned_type = *GCCTreec::fixup_unsigned_type;
*build_pointer_type_for_mode = *GCCTreec::build_pointer_type_for_mode;
*build_pointer_type = *GCCTreec::build_pointer_type;
*build_reference_type_for_mode = *GCCTreec::build_reference_type_for_mode;
*build_reference_type = *GCCTreec::build_reference_type;
*build_vector_type_for_mode = *GCCTreec::build_vector_type_for_mode;
*build_vector_type = *GCCTreec::build_vector_type;
*build_opaque_vector_type = *GCCTreec::build_opaque_vector_type;
*build_type_no_quals = *GCCTreec::build_type_no_quals;
*build_index_type = *GCCTreec::build_index_type;
*build_array_type = *GCCTreec::build_array_type;
*build_nonshared_array_type = *GCCTreec::build_nonshared_array_type;
*build_array_type_nelts = *GCCTreec::build_array_type_nelts;
*build_function_type = *GCCTreec::build_function_type;
*build_function_type_list = *GCCTreec::build_function_type_list;
*build_function_type_skip_args = *GCCTreec::build_function_type_skip_args;
*build_function_decl_skip_args = *GCCTreec::build_function_decl_skip_args;
*build_varargs_function_type_list = *GCCTreec::build_varargs_function_type_list;
*build_method_type_directly = *GCCTreec::build_method_type_directly;
*build_method_type = *GCCTreec::build_method_type;
*build_offset_type = *GCCTreec::build_offset_type;
*build_complex_type = *GCCTreec::build_complex_type;
*array_type_nelts = *GCCTreec::array_type_nelts;
*in_array_bounds_p = *GCCTreec::in_array_bounds_p;
*range_in_array_bounds_p = *GCCTreec::range_in_array_bounds_p;
*value_member = *GCCTreec::value_member;
*purpose_member = *GCCTreec::purpose_member;
*vec_member = *GCCTreec::vec_member;
*chain_index = *GCCTreec::chain_index;
*attribute_list_equal = *GCCTreec::attribute_list_equal;
*attribute_list_contained = *GCCTreec::attribute_list_contained;
*tree_int_cst_equal = *GCCTreec::tree_int_cst_equal;
*tree_int_cst_lt = *GCCTreec::tree_int_cst_lt;
*tree_int_cst_compare = *GCCTreec::tree_int_cst_compare;
*host_integerp = *GCCTreec::host_integerp;
*tree_low_cst = *GCCTreec::tree_low_cst;
*tree_int_cst_msb = *GCCTreec::tree_int_cst_msb;
*tree_int_cst_sgn = *GCCTreec::tree_int_cst_sgn;
*tree_int_cst_sign_bit = *GCCTreec::tree_int_cst_sign_bit;
*tree_int_cst_min_precision = *GCCTreec::tree_int_cst_min_precision;
*tree_expr_nonnegative_p = *GCCTreec::tree_expr_nonnegative_p;
*tree_expr_nonnegative_warnv_p = *GCCTreec::tree_expr_nonnegative_warnv_p;
*may_negate_without_overflow_p = *GCCTreec::may_negate_without_overflow_p;
*strip_array_types = *GCCTreec::strip_array_types;
*excess_precision_type = *GCCTreec::excess_precision_type;
*make_fract_type = *GCCTreec::make_fract_type;
*make_accum_type = *GCCTreec::make_accum_type;
*make_tree = *GCCTreec::make_tree;
*build_type_attribute_variant = *GCCTreec::build_type_attribute_variant;
*build_decl_attribute_variant = *GCCTreec::build_decl_attribute_variant;
*build_type_attribute_qual_variant = *GCCTreec::build_type_attribute_qual_variant;
*merge_decl_attributes = *GCCTreec::merge_decl_attributes;
*merge_type_attributes = *GCCTreec::merge_type_attributes;
*is_attribute_p = *GCCTreec::is_attribute_p;
*lookup_attribute = *GCCTreec::lookup_attribute;
*remove_attribute = *GCCTreec::remove_attribute;
*merge_attributes = *GCCTreec::merge_attributes;
*check_qualified_type = *GCCTreec::check_qualified_type;
*get_qualified_type = *GCCTreec::get_qualified_type;
*build_qualified_type = *GCCTreec::build_qualified_type;
*build_aligned_type = *GCCTreec::build_aligned_type;
*build_distinct_type_copy = *GCCTreec::build_distinct_type_copy;
*build_variant_type_copy = *GCCTreec::build_variant_type_copy;
*finish_builtin_struct = *GCCTreec::finish_builtin_struct;
*layout_type = *GCCTreec::layout_type;
*start_record_layout = *GCCTreec::start_record_layout;
*bit_from_pos = *GCCTreec::bit_from_pos;
*byte_from_pos = *GCCTreec::byte_from_pos;
*pos_from_bit = *GCCTreec::pos_from_bit;
*normalize_offset = *GCCTreec::normalize_offset;
*rli_size_unit_so_far = *GCCTreec::rli_size_unit_so_far;
*rli_size_so_far = *GCCTreec::rli_size_so_far;
*normalize_rli = *GCCTreec::normalize_rli;
*place_field = *GCCTreec::place_field;
*compute_record_mode = *GCCTreec::compute_record_mode;
*finish_record_layout = *GCCTreec::finish_record_layout;
*type_hash_canon = *GCCTreec::type_hash_canon;
*layout_decl = *GCCTreec::layout_decl;
*relayout_decl = *GCCTreec::relayout_decl;
*mode_for_size_tree = *GCCTreec::mode_for_size_tree;
*non_lvalue_loc = *GCCTreec::non_lvalue_loc;
*convert = *GCCTreec::convert;
*expr_align = *GCCTreec::expr_align;
*expr_first = *GCCTreec::expr_first;
*expr_last = *GCCTreec::expr_last;
*size_in_bytes = *GCCTreec::size_in_bytes;
*int_size_in_bytes = *GCCTreec::int_size_in_bytes;
*max_int_size_in_bytes = *GCCTreec::max_int_size_in_bytes;
*tree_expr_size = *GCCTreec::tree_expr_size;
*bit_position = *GCCTreec::bit_position;
*int_bit_position = *GCCTreec::int_bit_position;
*byte_position = *GCCTreec::byte_position;
*int_byte_position = *GCCTreec::int_byte_position;

############# Class : GCCTree::tree_base ##############

package GCCTree::tree_base;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_code_get = *GCCTreec::tree_base_code_get;
*swig_code_set = *GCCTreec::tree_base_code_set;
*swig_side_effects_flag_get = *GCCTreec::tree_base_side_effects_flag_get;
*swig_side_effects_flag_set = *GCCTreec::tree_base_side_effects_flag_set;
*swig_constant_flag_get = *GCCTreec::tree_base_constant_flag_get;
*swig_constant_flag_set = *GCCTreec::tree_base_constant_flag_set;
*swig_addressable_flag_get = *GCCTreec::tree_base_addressable_flag_get;
*swig_addressable_flag_set = *GCCTreec::tree_base_addressable_flag_set;
*swig_volatile_flag_get = *GCCTreec::tree_base_volatile_flag_get;
*swig_volatile_flag_set = *GCCTreec::tree_base_volatile_flag_set;
*swig_readonly_flag_get = *GCCTreec::tree_base_readonly_flag_get;
*swig_readonly_flag_set = *GCCTreec::tree_base_readonly_flag_set;
*swig_unsigned_flag_get = *GCCTreec::tree_base_unsigned_flag_get;
*swig_unsigned_flag_set = *GCCTreec::tree_base_unsigned_flag_set;
*swig_asm_written_flag_get = *GCCTreec::tree_base_asm_written_flag_get;
*swig_asm_written_flag_set = *GCCTreec::tree_base_asm_written_flag_set;
*swig_nowarning_flag_get = *GCCTreec::tree_base_nowarning_flag_get;
*swig_nowarning_flag_set = *GCCTreec::tree_base_nowarning_flag_set;
*swig_used_flag_get = *GCCTreec::tree_base_used_flag_get;
*swig_used_flag_set = *GCCTreec::tree_base_used_flag_set;
*swig_nothrow_flag_get = *GCCTreec::tree_base_nothrow_flag_get;
*swig_nothrow_flag_set = *GCCTreec::tree_base_nothrow_flag_set;
*swig_static_flag_get = *GCCTreec::tree_base_static_flag_get;
*swig_static_flag_set = *GCCTreec::tree_base_static_flag_set;
*swig_public_flag_get = *GCCTreec::tree_base_public_flag_get;
*swig_public_flag_set = *GCCTreec::tree_base_public_flag_set;
*swig_private_flag_get = *GCCTreec::tree_base_private_flag_get;
*swig_private_flag_set = *GCCTreec::tree_base_private_flag_set;
*swig_protected_flag_get = *GCCTreec::tree_base_protected_flag_get;
*swig_protected_flag_set = *GCCTreec::tree_base_protected_flag_set;
*swig_deprecated_flag_get = *GCCTreec::tree_base_deprecated_flag_get;
*swig_deprecated_flag_set = *GCCTreec::tree_base_deprecated_flag_set;
*swig_saturating_flag_get = *GCCTreec::tree_base_saturating_flag_get;
*swig_saturating_flag_set = *GCCTreec::tree_base_saturating_flag_set;
*swig_default_def_flag_get = *GCCTreec::tree_base_default_def_flag_get;
*swig_default_def_flag_set = *GCCTreec::tree_base_default_def_flag_set;
*swig_lang_flag_0_get = *GCCTreec::tree_base_lang_flag_0_get;
*swig_lang_flag_0_set = *GCCTreec::tree_base_lang_flag_0_set;
*swig_lang_flag_1_get = *GCCTreec::tree_base_lang_flag_1_get;
*swig_lang_flag_1_set = *GCCTreec::tree_base_lang_flag_1_set;
*swig_lang_flag_2_get = *GCCTreec::tree_base_lang_flag_2_get;
*swig_lang_flag_2_set = *GCCTreec::tree_base_lang_flag_2_set;
*swig_lang_flag_3_get = *GCCTreec::tree_base_lang_flag_3_get;
*swig_lang_flag_3_set = *GCCTreec::tree_base_lang_flag_3_set;
*swig_lang_flag_4_get = *GCCTreec::tree_base_lang_flag_4_get;
*swig_lang_flag_4_set = *GCCTreec::tree_base_lang_flag_4_set;
*swig_lang_flag_5_get = *GCCTreec::tree_base_lang_flag_5_get;
*swig_lang_flag_5_set = *GCCTreec::tree_base_lang_flag_5_set;
*swig_lang_flag_6_get = *GCCTreec::tree_base_lang_flag_6_get;
*swig_lang_flag_6_set = *GCCTreec::tree_base_lang_flag_6_set;
*swig_visited_get = *GCCTreec::tree_base_visited_get;
*swig_visited_set = *GCCTreec::tree_base_visited_set;
*swig_packed_flag_get = *GCCTreec::tree_base_packed_flag_get;
*swig_packed_flag_set = *GCCTreec::tree_base_packed_flag_set;
*swig_user_align_get = *GCCTreec::tree_base_user_align_get;
*swig_user_align_set = *GCCTreec::tree_base_user_align_set;
*swig_nameless_flag_get = *GCCTreec::tree_base_nameless_flag_get;
*swig_nameless_flag_set = *GCCTreec::tree_base_nameless_flag_set;
*swig_spare_get = *GCCTreec::tree_base_spare_get;
*swig_spare_set = *GCCTreec::tree_base_spare_set;
*swig_address_space_get = *GCCTreec::tree_base_address_space_get;
*swig_address_space_set = *GCCTreec::tree_base_address_space_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_base(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_base($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_common ##############

package GCCTree::tree_common;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_base_get = *GCCTreec::tree_common_base_get;
*swig_base_set = *GCCTreec::tree_common_base_set;
*swig_chain_get = *GCCTreec::tree_common_chain_get;
*swig_chain_set = *GCCTreec::tree_common_chain_set;
*swig_type_get = *GCCTreec::tree_common_type_get;
*swig_type_set = *GCCTreec::tree_common_type_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_common(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_common($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_int_cst ##############

package GCCTree::tree_int_cst;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_int_cst_common_get;
*swig_common_set = *GCCTreec::tree_int_cst_common_set;
*swig_int_cst_get = *GCCTreec::tree_int_cst_int_cst_get;
*swig_int_cst_set = *GCCTreec::tree_int_cst_int_cst_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_int_cst(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_int_cst($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_real_cst ##############

package GCCTree::tree_real_cst;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_real_cst_common_get;
*swig_common_set = *GCCTreec::tree_real_cst_common_set;
*swig_real_cst_ptr_get = *GCCTreec::tree_real_cst_real_cst_ptr_get;
*swig_real_cst_ptr_set = *GCCTreec::tree_real_cst_real_cst_ptr_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_real_cst(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_real_cst($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_fixed_cst ##############

package GCCTree::tree_fixed_cst;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_fixed_cst_common_get;
*swig_common_set = *GCCTreec::tree_fixed_cst_common_set;
*swig_fixed_cst_ptr_get = *GCCTreec::tree_fixed_cst_fixed_cst_ptr_get;
*swig_fixed_cst_ptr_set = *GCCTreec::tree_fixed_cst_fixed_cst_ptr_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_fixed_cst(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_fixed_cst($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_string ##############

package GCCTree::tree_string;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_string_common_get;
*swig_common_set = *GCCTreec::tree_string_common_set;
*swig_length_get = *GCCTreec::tree_string_length_get;
*swig_length_set = *GCCTreec::tree_string_length_set;
*swig_str_get = *GCCTreec::tree_string_str_get;
*swig_str_set = *GCCTreec::tree_string_str_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_string(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_string($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_complex ##############

package GCCTree::tree_complex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_complex_common_get;
*swig_common_set = *GCCTreec::tree_complex_common_set;
*swig_real_get = *GCCTreec::tree_complex_real_get;
*swig_real_set = *GCCTreec::tree_complex_real_set;
*swig_imag_get = *GCCTreec::tree_complex_imag_get;
*swig_imag_set = *GCCTreec::tree_complex_imag_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_complex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_complex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_vector ##############

package GCCTree::tree_vector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_vector_common_get;
*swig_common_set = *GCCTreec::tree_vector_common_set;
*swig_elements_get = *GCCTreec::tree_vector_elements_get;
*swig_elements_set = *GCCTreec::tree_vector_elements_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_vector(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_vector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::_obstack_chunk ##############

package GCCTree::_obstack_chunk;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_limit_get = *GCCTreec::_obstack_chunk_limit_get;
*swig_limit_set = *GCCTreec::_obstack_chunk_limit_set;
*swig_prev_get = *GCCTreec::_obstack_chunk_prev_get;
*swig_prev_set = *GCCTreec::_obstack_chunk_prev_set;
*swig_contents_get = *GCCTreec::_obstack_chunk_contents_get;
*swig_contents_set = *GCCTreec::_obstack_chunk_contents_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new__obstack_chunk(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete__obstack_chunk($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::obstack ##############

package GCCTree::obstack;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_chunk_size_get = *GCCTreec::obstack_chunk_size_get;
*swig_chunk_size_set = *GCCTreec::obstack_chunk_size_set;
*swig_chunk_get = *GCCTreec::obstack_chunk_get;
*swig_chunk_set = *GCCTreec::obstack_chunk_set;
*swig_object_base_get = *GCCTreec::obstack_object_base_get;
*swig_object_base_set = *GCCTreec::obstack_object_base_set;
*swig_next_free_get = *GCCTreec::obstack_next_free_get;
*swig_next_free_set = *GCCTreec::obstack_next_free_set;
*swig_chunk_limit_get = *GCCTreec::obstack_chunk_limit_get;
*swig_chunk_limit_set = *GCCTreec::obstack_chunk_limit_set;
*swig_temp_get = *GCCTreec::obstack_temp_get;
*swig_temp_set = *GCCTreec::obstack_temp_set;
*swig_alignment_mask_get = *GCCTreec::obstack_alignment_mask_get;
*swig_alignment_mask_set = *GCCTreec::obstack_alignment_mask_set;
*swig_chunkfun_get = *GCCTreec::obstack_chunkfun_get;
*swig_chunkfun_set = *GCCTreec::obstack_chunkfun_set;
*swig_freefun_get = *GCCTreec::obstack_freefun_get;
*swig_freefun_set = *GCCTreec::obstack_freefun_set;
*swig_extra_arg_get = *GCCTreec::obstack_extra_arg_get;
*swig_extra_arg_set = *GCCTreec::obstack_extra_arg_set;
*swig_use_extra_arg_get = *GCCTreec::obstack_use_extra_arg_get;
*swig_use_extra_arg_set = *GCCTreec::obstack_use_extra_arg_set;
*swig_maybe_empty_object_get = *GCCTreec::obstack_maybe_empty_object_get;
*swig_maybe_empty_object_set = *GCCTreec::obstack_maybe_empty_object_set;
*swig_alloc_failed_get = *GCCTreec::obstack_alloc_failed_get;
*swig_alloc_failed_set = *GCCTreec::obstack_alloc_failed_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_obstack(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_obstack($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::ht_identifier ##############

package GCCTree::ht_identifier;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_str_get = *GCCTreec::ht_identifier_str_get;
*swig_str_set = *GCCTreec::ht_identifier_str_set;
*swig_len_get = *GCCTreec::ht_identifier_len_get;
*swig_len_set = *GCCTreec::ht_identifier_len_set;
*swig_hash_value_get = *GCCTreec::ht_identifier_hash_value_get;
*swig_hash_value_set = *GCCTreec::ht_identifier_hash_value_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_ht_identifier(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_ht_identifier($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::ht ##############

package GCCTree::ht;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_stack_get = *GCCTreec::ht_stack_get;
*swig_stack_set = *GCCTreec::ht_stack_set;
*swig_entries_get = *GCCTreec::ht_entries_get;
*swig_entries_set = *GCCTreec::ht_entries_set;
*swig_alloc_node_get = *GCCTreec::ht_alloc_node_get;
*swig_alloc_node_set = *GCCTreec::ht_alloc_node_set;
*swig_alloc_subobject_get = *GCCTreec::ht_alloc_subobject_get;
*swig_alloc_subobject_set = *GCCTreec::ht_alloc_subobject_set;
*swig_nslots_get = *GCCTreec::ht_nslots_get;
*swig_nslots_set = *GCCTreec::ht_nslots_set;
*swig_nelements_get = *GCCTreec::ht_nelements_get;
*swig_nelements_set = *GCCTreec::ht_nelements_set;
*swig_pfile_get = *GCCTreec::ht_pfile_get;
*swig_pfile_set = *GCCTreec::ht_pfile_set;
*swig_searches_get = *GCCTreec::ht_searches_get;
*swig_searches_set = *GCCTreec::ht_searches_set;
*swig_collisions_get = *GCCTreec::ht_collisions_get;
*swig_collisions_set = *GCCTreec::ht_collisions_set;
*swig_entries_owned_get = *GCCTreec::ht_entries_owned_get;
*swig_entries_owned_set = *GCCTreec::ht_entries_owned_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_ht(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_ht($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_identifier ##############

package GCCTree::tree_identifier;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_identifier_common_get;
*swig_common_set = *GCCTreec::tree_identifier_common_set;
*swig_id_get = *GCCTreec::tree_identifier_id_get;
*swig_id_set = *GCCTreec::tree_identifier_id_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_identifier(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_identifier($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_list ##############

package GCCTree::tree_list;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_list_common_get;
*swig_common_set = *GCCTreec::tree_list_common_set;
*swig_purpose_get = *GCCTreec::tree_list_purpose_get;
*swig_purpose_set = *GCCTreec::tree_list_purpose_set;
*swig_value_get = *GCCTreec::tree_list_value_get;
*swig_value_set = *GCCTreec::tree_list_value_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_list(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_list($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_vec ##############

package GCCTree::tree_vec;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_vec_common_get;
*swig_common_set = *GCCTreec::tree_vec_common_set;
*swig_length_get = *GCCTreec::tree_vec_length_get;
*swig_length_set = *GCCTreec::tree_vec_length_set;
*swig_a_get = *GCCTreec::tree_vec_a_get;
*swig_a_set = *GCCTreec::tree_vec_a_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_vec(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_vec($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::constructor_elt ##############

package GCCTree::constructor_elt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_index_get = *GCCTreec::constructor_elt_index_get;
*swig_index_set = *GCCTreec::constructor_elt_index_set;
*swig_value_get = *GCCTreec::constructor_elt_value_get;
*swig_value_set = *GCCTreec::constructor_elt_value_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_constructor_elt(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_constructor_elt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::VEC_constructor_elt_base ##############

package GCCTree::VEC_constructor_elt_base;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_num_get = *GCCTreec::VEC_constructor_elt_base_num_get;
*swig_num_set = *GCCTreec::VEC_constructor_elt_base_num_set;
*swig_alloc_get = *GCCTreec::VEC_constructor_elt_base_alloc_get;
*swig_alloc_set = *GCCTreec::VEC_constructor_elt_base_alloc_set;
*swig_vec_get = *GCCTreec::VEC_constructor_elt_base_vec_get;
*swig_vec_set = *GCCTreec::VEC_constructor_elt_base_vec_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_VEC_constructor_elt_base(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_VEC_constructor_elt_base($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::VEC_constructor_elt_none ##############

package GCCTree::VEC_constructor_elt_none;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_base_get = *GCCTreec::VEC_constructor_elt_none_base_get;
*swig_base_set = *GCCTreec::VEC_constructor_elt_none_base_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_VEC_constructor_elt_none(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_VEC_constructor_elt_none($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::VEC_constructor_elt_gc ##############

package GCCTree::VEC_constructor_elt_gc;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_base_get = *GCCTreec::VEC_constructor_elt_gc_base_get;
*swig_base_set = *GCCTreec::VEC_constructor_elt_gc_base_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_VEC_constructor_elt_gc(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_VEC_constructor_elt_gc($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_constructor ##############

package GCCTree::tree_constructor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_constructor_common_get;
*swig_common_set = *GCCTreec::tree_constructor_common_set;
*swig_elts_get = *GCCTreec::tree_constructor_elts_get;
*swig_elts_set = *GCCTreec::tree_constructor_elts_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_constructor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_constructor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_exp ##############

package GCCTree::tree_exp;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_exp_common_get;
*swig_common_set = *GCCTreec::tree_exp_common_set;
*swig_locus_get = *GCCTreec::tree_exp_locus_get;
*swig_locus_set = *GCCTreec::tree_exp_locus_set;
*swig_block_get = *GCCTreec::tree_exp_block_get;
*swig_block_set = *GCCTreec::tree_exp_block_set;
*swig_operands_get = *GCCTreec::tree_exp_operands_get;
*swig_operands_set = *GCCTreec::tree_exp_operands_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_exp(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_exp($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::ssa_use_operand_t ##############

package GCCTree::ssa_use_operand_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_prev_get = *GCCTreec::ssa_use_operand_t_prev_get;
*swig_prev_set = *GCCTreec::ssa_use_operand_t_prev_set;
*swig_next_get = *GCCTreec::ssa_use_operand_t_next_get;
*swig_next_set = *GCCTreec::ssa_use_operand_t_next_set;
*swig_use_get = *GCCTreec::ssa_use_operand_t_use_get;
*swig_use_set = *GCCTreec::ssa_use_operand_t_use_set;
*swig_loc_get = *GCCTreec::ssa_use_operand_t_loc_get;
*swig_loc_set = *GCCTreec::ssa_use_operand_t_loc_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_ssa_use_operand_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_ssa_use_operand_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::ssa_use_operand_t_loc ##############

package GCCTree::ssa_use_operand_t_loc;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_stmt_get = *GCCTreec::ssa_use_operand_t_loc_stmt_get;
*swig_stmt_set = *GCCTreec::ssa_use_operand_t_loc_stmt_set;
*swig_ssa_name_get = *GCCTreec::ssa_use_operand_t_loc_ssa_name_get;
*swig_ssa_name_set = *GCCTreec::ssa_use_operand_t_loc_ssa_name_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_ssa_use_operand_t_loc(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_ssa_use_operand_t_loc($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_ssa_name ##############

package GCCTree::tree_ssa_name;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_ssa_name_common_get;
*swig_common_set = *GCCTreec::tree_ssa_name_common_set;
*swig_var_get = *GCCTreec::tree_ssa_name_var_get;
*swig_var_set = *GCCTreec::tree_ssa_name_var_set;
*swig_def_stmt_get = *GCCTreec::tree_ssa_name_def_stmt_get;
*swig_def_stmt_set = *GCCTreec::tree_ssa_name_def_stmt_set;
*swig_version_get = *GCCTreec::tree_ssa_name_version_get;
*swig_version_set = *GCCTreec::tree_ssa_name_version_set;
*swig_ptr_info_get = *GCCTreec::tree_ssa_name_ptr_info_get;
*swig_ptr_info_set = *GCCTreec::tree_ssa_name_ptr_info_set;
*swig_imm_uses_get = *GCCTreec::tree_ssa_name_imm_uses_get;
*swig_imm_uses_set = *GCCTreec::tree_ssa_name_imm_uses_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_ssa_name(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_ssa_name($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::phi_arg_d ##############

package GCCTree::phi_arg_d;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_imm_use_get = *GCCTreec::phi_arg_d_imm_use_get;
*swig_imm_use_set = *GCCTreec::phi_arg_d_imm_use_set;
*swig_def_get = *GCCTreec::phi_arg_d_def_get;
*swig_def_set = *GCCTreec::phi_arg_d_def_set;
*swig_locus_get = *GCCTreec::phi_arg_d_locus_get;
*swig_locus_set = *GCCTreec::phi_arg_d_locus_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_phi_arg_d(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_phi_arg_d($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_omp_clause ##############

package GCCTree::tree_omp_clause;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_omp_clause_common_get;
*swig_common_set = *GCCTreec::tree_omp_clause_common_set;
*swig_locus_get = *GCCTreec::tree_omp_clause_locus_get;
*swig_locus_set = *GCCTreec::tree_omp_clause_locus_set;
*swig_code_get = *GCCTreec::tree_omp_clause_code_get;
*swig_code_set = *GCCTreec::tree_omp_clause_code_set;
*swig_gimple_reduction_init_get = *GCCTreec::tree_omp_clause_gimple_reduction_init_get;
*swig_gimple_reduction_init_set = *GCCTreec::tree_omp_clause_gimple_reduction_init_set;
*swig_gimple_reduction_merge_get = *GCCTreec::tree_omp_clause_gimple_reduction_merge_get;
*swig_gimple_reduction_merge_set = *GCCTreec::tree_omp_clause_gimple_reduction_merge_set;
*swig_ops_get = *GCCTreec::tree_omp_clause_ops_get;
*swig_ops_set = *GCCTreec::tree_omp_clause_ops_set;
*swig_subcode_get = *GCCTreec::tree_omp_clause_subcode_get;
*swig_subcode_set = *GCCTreec::tree_omp_clause_subcode_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_omp_clause(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_omp_clause($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_omp_clause_subcode ##############

package GCCTree::tree_omp_clause_subcode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_default_kind_get = *GCCTreec::tree_omp_clause_subcode_default_kind_get;
*swig_default_kind_set = *GCCTreec::tree_omp_clause_subcode_default_kind_set;
*swig_schedule_kind_get = *GCCTreec::tree_omp_clause_subcode_schedule_kind_get;
*swig_schedule_kind_set = *GCCTreec::tree_omp_clause_subcode_schedule_kind_set;
*swig_reduction_code_get = *GCCTreec::tree_omp_clause_subcode_reduction_code_get;
*swig_reduction_code_set = *GCCTreec::tree_omp_clause_subcode_reduction_code_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_omp_clause_subcode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_omp_clause_subcode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_block ##############

package GCCTree::tree_block;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_block_common_get;
*swig_common_set = *GCCTreec::tree_block_common_set;
*swig_abstract_flag_get = *GCCTreec::tree_block_abstract_flag_get;
*swig_abstract_flag_set = *GCCTreec::tree_block_abstract_flag_set;
*swig_block_num_get = *GCCTreec::tree_block_block_num_get;
*swig_block_num_set = *GCCTreec::tree_block_block_num_set;
*swig_locus_get = *GCCTreec::tree_block_locus_get;
*swig_locus_set = *GCCTreec::tree_block_locus_set;
*swig_vars_get = *GCCTreec::tree_block_vars_get;
*swig_vars_set = *GCCTreec::tree_block_vars_set;
*swig_nonlocalized_vars_get = *GCCTreec::tree_block_nonlocalized_vars_get;
*swig_nonlocalized_vars_set = *GCCTreec::tree_block_nonlocalized_vars_set;
*swig_subblocks_get = *GCCTreec::tree_block_subblocks_get;
*swig_subblocks_set = *GCCTreec::tree_block_subblocks_set;
*swig_supercontext_get = *GCCTreec::tree_block_supercontext_get;
*swig_supercontext_set = *GCCTreec::tree_block_supercontext_set;
*swig_abstract_origin_get = *GCCTreec::tree_block_abstract_origin_get;
*swig_abstract_origin_set = *GCCTreec::tree_block_abstract_origin_set;
*swig_fragment_origin_get = *GCCTreec::tree_block_fragment_origin_get;
*swig_fragment_origin_set = *GCCTreec::tree_block_fragment_origin_set;
*swig_fragment_chain_get = *GCCTreec::tree_block_fragment_chain_get;
*swig_fragment_chain_set = *GCCTreec::tree_block_fragment_chain_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_block(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_block($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_type ##############

package GCCTree::tree_type;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_type_common_get;
*swig_common_set = *GCCTreec::tree_type_common_set;
*swig_values_get = *GCCTreec::tree_type_values_get;
*swig_values_set = *GCCTreec::tree_type_values_set;
*swig_size_get = *GCCTreec::tree_type_size_get;
*swig_size_set = *GCCTreec::tree_type_size_set;
*swig_size_unit_get = *GCCTreec::tree_type_size_unit_get;
*swig_size_unit_set = *GCCTreec::tree_type_size_unit_set;
*swig_attributes_get = *GCCTreec::tree_type_attributes_get;
*swig_attributes_set = *GCCTreec::tree_type_attributes_set;
*swig_uid_get = *GCCTreec::tree_type_uid_get;
*swig_uid_set = *GCCTreec::tree_type_uid_set;
*swig_precision_get = *GCCTreec::tree_type_precision_get;
*swig_precision_set = *GCCTreec::tree_type_precision_set;
*swig_no_force_blk_flag_get = *GCCTreec::tree_type_no_force_blk_flag_get;
*swig_no_force_blk_flag_set = *GCCTreec::tree_type_no_force_blk_flag_set;
*swig_needs_constructing_flag_get = *GCCTreec::tree_type_needs_constructing_flag_get;
*swig_needs_constructing_flag_set = *GCCTreec::tree_type_needs_constructing_flag_set;
*swig_transparent_aggr_flag_get = *GCCTreec::tree_type_transparent_aggr_flag_get;
*swig_transparent_aggr_flag_set = *GCCTreec::tree_type_transparent_aggr_flag_set;
*swig_restrict_flag_get = *GCCTreec::tree_type_restrict_flag_get;
*swig_restrict_flag_set = *GCCTreec::tree_type_restrict_flag_set;
*swig_contains_placeholder_bits_get = *GCCTreec::tree_type_contains_placeholder_bits_get;
*swig_contains_placeholder_bits_set = *GCCTreec::tree_type_contains_placeholder_bits_set;
*swig_mode_get = *GCCTreec::tree_type_mode_get;
*swig_mode_set = *GCCTreec::tree_type_mode_set;
*swig_string_flag_get = *GCCTreec::tree_type_string_flag_get;
*swig_string_flag_set = *GCCTreec::tree_type_string_flag_set;
*swig_lang_flag_0_get = *GCCTreec::tree_type_lang_flag_0_get;
*swig_lang_flag_0_set = *GCCTreec::tree_type_lang_flag_0_set;
*swig_lang_flag_1_get = *GCCTreec::tree_type_lang_flag_1_get;
*swig_lang_flag_1_set = *GCCTreec::tree_type_lang_flag_1_set;
*swig_lang_flag_2_get = *GCCTreec::tree_type_lang_flag_2_get;
*swig_lang_flag_2_set = *GCCTreec::tree_type_lang_flag_2_set;
*swig_lang_flag_3_get = *GCCTreec::tree_type_lang_flag_3_get;
*swig_lang_flag_3_set = *GCCTreec::tree_type_lang_flag_3_set;
*swig_lang_flag_4_get = *GCCTreec::tree_type_lang_flag_4_get;
*swig_lang_flag_4_set = *GCCTreec::tree_type_lang_flag_4_set;
*swig_lang_flag_5_get = *GCCTreec::tree_type_lang_flag_5_get;
*swig_lang_flag_5_set = *GCCTreec::tree_type_lang_flag_5_set;
*swig_lang_flag_6_get = *GCCTreec::tree_type_lang_flag_6_get;
*swig_lang_flag_6_set = *GCCTreec::tree_type_lang_flag_6_set;
*swig_align_get = *GCCTreec::tree_type_align_get;
*swig_align_set = *GCCTreec::tree_type_align_set;
*swig_alias_set_get = *GCCTreec::tree_type_alias_set_get;
*swig_alias_set_set = *GCCTreec::tree_type_alias_set_set;
*swig_pointer_to_get = *GCCTreec::tree_type_pointer_to_get;
*swig_pointer_to_set = *GCCTreec::tree_type_pointer_to_set;
*swig_reference_to_get = *GCCTreec::tree_type_reference_to_get;
*swig_reference_to_set = *GCCTreec::tree_type_reference_to_set;
*swig_name_get = *GCCTreec::tree_type_name_get;
*swig_name_set = *GCCTreec::tree_type_name_set;
*swig_minval_get = *GCCTreec::tree_type_minval_get;
*swig_minval_set = *GCCTreec::tree_type_minval_set;
*swig_maxval_get = *GCCTreec::tree_type_maxval_get;
*swig_maxval_set = *GCCTreec::tree_type_maxval_set;
*swig_next_variant_get = *GCCTreec::tree_type_next_variant_get;
*swig_next_variant_set = *GCCTreec::tree_type_next_variant_set;
*swig_main_variant_get = *GCCTreec::tree_type_main_variant_get;
*swig_main_variant_set = *GCCTreec::tree_type_main_variant_set;
*swig_binfo_get = *GCCTreec::tree_type_binfo_get;
*swig_binfo_set = *GCCTreec::tree_type_binfo_set;
*swig_context_get = *GCCTreec::tree_type_context_get;
*swig_context_set = *GCCTreec::tree_type_context_set;
*swig_canonical_get = *GCCTreec::tree_type_canonical_get;
*swig_canonical_set = *GCCTreec::tree_type_canonical_set;
*swig_lang_specific_get = *GCCTreec::tree_type_lang_specific_get;
*swig_lang_specific_set = *GCCTreec::tree_type_lang_specific_set;
*swig_symtab_get = *GCCTreec::tree_type_symtab_get;
*swig_symtab_set = *GCCTreec::tree_type_symtab_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_type(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_type($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_type_symtab ##############

package GCCTree::tree_type_symtab;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_address_get = *GCCTreec::tree_type_symtab_address_get;
*swig_address_set = *GCCTreec::tree_type_symtab_address_set;
*swig_pointer_get = *GCCTreec::tree_type_symtab_pointer_get;
*swig_pointer_set = *GCCTreec::tree_type_symtab_pointer_set;
*swig_die_get = *GCCTreec::tree_type_symtab_die_get;
*swig_die_set = *GCCTreec::tree_type_symtab_die_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_type_symtab(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_type_symtab($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_binfo ##############

package GCCTree::tree_binfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_binfo_common_get;
*swig_common_set = *GCCTreec::tree_binfo_common_set;
*swig_offset_get = *GCCTreec::tree_binfo_offset_get;
*swig_offset_set = *GCCTreec::tree_binfo_offset_set;
*swig_vtable_get = *GCCTreec::tree_binfo_vtable_get;
*swig_vtable_set = *GCCTreec::tree_binfo_vtable_set;
*swig_virtuals_get = *GCCTreec::tree_binfo_virtuals_get;
*swig_virtuals_set = *GCCTreec::tree_binfo_virtuals_set;
*swig_vptr_field_get = *GCCTreec::tree_binfo_vptr_field_get;
*swig_vptr_field_set = *GCCTreec::tree_binfo_vptr_field_set;
*swig_base_accesses_get = *GCCTreec::tree_binfo_base_accesses_get;
*swig_base_accesses_set = *GCCTreec::tree_binfo_base_accesses_set;
*swig_inheritance_get = *GCCTreec::tree_binfo_inheritance_get;
*swig_inheritance_set = *GCCTreec::tree_binfo_inheritance_set;
*swig_vtt_subvtt_get = *GCCTreec::tree_binfo_vtt_subvtt_get;
*swig_vtt_subvtt_set = *GCCTreec::tree_binfo_vtt_subvtt_set;
*swig_vtt_vptr_get = *GCCTreec::tree_binfo_vtt_vptr_get;
*swig_vtt_vptr_set = *GCCTreec::tree_binfo_vtt_vptr_set;
*swig_base_binfos_get = *GCCTreec::tree_binfo_base_binfos_get;
*swig_base_binfos_set = *GCCTreec::tree_binfo_base_binfos_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_binfo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_binfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_decl_minimal ##############

package GCCTree::tree_decl_minimal;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_decl_minimal_common_get;
*swig_common_set = *GCCTreec::tree_decl_minimal_common_set;
*swig_locus_get = *GCCTreec::tree_decl_minimal_locus_get;
*swig_locus_set = *GCCTreec::tree_decl_minimal_locus_set;
*swig_uid_get = *GCCTreec::tree_decl_minimal_uid_get;
*swig_uid_set = *GCCTreec::tree_decl_minimal_uid_set;
*swig_name_get = *GCCTreec::tree_decl_minimal_name_get;
*swig_name_set = *GCCTreec::tree_decl_minimal_name_set;
*swig_context_get = *GCCTreec::tree_decl_minimal_context_get;
*swig_context_set = *GCCTreec::tree_decl_minimal_context_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_decl_minimal(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_decl_minimal($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_decl_common ##############

package GCCTree::tree_decl_common;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_decl_common_common_get;
*swig_common_set = *GCCTreec::tree_decl_common_common_set;
*swig_size_get = *GCCTreec::tree_decl_common_size_get;
*swig_size_set = *GCCTreec::tree_decl_common_size_set;
*swig_mode_get = *GCCTreec::tree_decl_common_mode_get;
*swig_mode_set = *GCCTreec::tree_decl_common_mode_set;
*swig_nonlocal_flag_get = *GCCTreec::tree_decl_common_nonlocal_flag_get;
*swig_nonlocal_flag_set = *GCCTreec::tree_decl_common_nonlocal_flag_set;
*swig_virtual_flag_get = *GCCTreec::tree_decl_common_virtual_flag_get;
*swig_virtual_flag_set = *GCCTreec::tree_decl_common_virtual_flag_set;
*swig_ignored_flag_get = *GCCTreec::tree_decl_common_ignored_flag_get;
*swig_ignored_flag_set = *GCCTreec::tree_decl_common_ignored_flag_set;
*swig_abstract_flag_get = *GCCTreec::tree_decl_common_abstract_flag_get;
*swig_abstract_flag_set = *GCCTreec::tree_decl_common_abstract_flag_set;
*swig_artificial_flag_get = *GCCTreec::tree_decl_common_artificial_flag_get;
*swig_artificial_flag_set = *GCCTreec::tree_decl_common_artificial_flag_set;
*swig_preserve_flag_get = *GCCTreec::tree_decl_common_preserve_flag_get;
*swig_preserve_flag_set = *GCCTreec::tree_decl_common_preserve_flag_set;
*swig_debug_expr_is_from_get = *GCCTreec::tree_decl_common_debug_expr_is_from_get;
*swig_debug_expr_is_from_set = *GCCTreec::tree_decl_common_debug_expr_is_from_set;
*swig_lang_flag_0_get = *GCCTreec::tree_decl_common_lang_flag_0_get;
*swig_lang_flag_0_set = *GCCTreec::tree_decl_common_lang_flag_0_set;
*swig_lang_flag_1_get = *GCCTreec::tree_decl_common_lang_flag_1_get;
*swig_lang_flag_1_set = *GCCTreec::tree_decl_common_lang_flag_1_set;
*swig_lang_flag_2_get = *GCCTreec::tree_decl_common_lang_flag_2_get;
*swig_lang_flag_2_set = *GCCTreec::tree_decl_common_lang_flag_2_set;
*swig_lang_flag_3_get = *GCCTreec::tree_decl_common_lang_flag_3_get;
*swig_lang_flag_3_set = *GCCTreec::tree_decl_common_lang_flag_3_set;
*swig_lang_flag_4_get = *GCCTreec::tree_decl_common_lang_flag_4_get;
*swig_lang_flag_4_set = *GCCTreec::tree_decl_common_lang_flag_4_set;
*swig_lang_flag_5_get = *GCCTreec::tree_decl_common_lang_flag_5_get;
*swig_lang_flag_5_set = *GCCTreec::tree_decl_common_lang_flag_5_set;
*swig_lang_flag_6_get = *GCCTreec::tree_decl_common_lang_flag_6_get;
*swig_lang_flag_6_set = *GCCTreec::tree_decl_common_lang_flag_6_set;
*swig_lang_flag_7_get = *GCCTreec::tree_decl_common_lang_flag_7_get;
*swig_lang_flag_7_set = *GCCTreec::tree_decl_common_lang_flag_7_set;
*swig_lang_flag_8_get = *GCCTreec::tree_decl_common_lang_flag_8_get;
*swig_lang_flag_8_set = *GCCTreec::tree_decl_common_lang_flag_8_set;
*swig_decl_flag_0_get = *GCCTreec::tree_decl_common_decl_flag_0_get;
*swig_decl_flag_0_set = *GCCTreec::tree_decl_common_decl_flag_0_set;
*swig_decl_flag_1_get = *GCCTreec::tree_decl_common_decl_flag_1_get;
*swig_decl_flag_1_set = *GCCTreec::tree_decl_common_decl_flag_1_set;
*swig_decl_flag_2_get = *GCCTreec::tree_decl_common_decl_flag_2_get;
*swig_decl_flag_2_set = *GCCTreec::tree_decl_common_decl_flag_2_set;
*swig_gimple_reg_flag_get = *GCCTreec::tree_decl_common_gimple_reg_flag_get;
*swig_gimple_reg_flag_set = *GCCTreec::tree_decl_common_gimple_reg_flag_set;
*swig_decl_by_reference_flag_get = *GCCTreec::tree_decl_common_decl_by_reference_flag_get;
*swig_decl_by_reference_flag_set = *GCCTreec::tree_decl_common_decl_by_reference_flag_set;
*swig_decl_restricted_flag_get = *GCCTreec::tree_decl_common_decl_restricted_flag_get;
*swig_decl_restricted_flag_set = *GCCTreec::tree_decl_common_decl_restricted_flag_set;
*swig_decl_read_flag_get = *GCCTreec::tree_decl_common_decl_read_flag_get;
*swig_decl_read_flag_set = *GCCTreec::tree_decl_common_decl_read_flag_set;
*swig_decl_nonshareable_flag_get = *GCCTreec::tree_decl_common_decl_nonshareable_flag_get;
*swig_decl_nonshareable_flag_set = *GCCTreec::tree_decl_common_decl_nonshareable_flag_set;
*swig_off_align_get = *GCCTreec::tree_decl_common_off_align_get;
*swig_off_align_set = *GCCTreec::tree_decl_common_off_align_set;
*swig_align_get = *GCCTreec::tree_decl_common_align_get;
*swig_align_set = *GCCTreec::tree_decl_common_align_set;
*swig_pt_uid_get = *GCCTreec::tree_decl_common_pt_uid_get;
*swig_pt_uid_set = *GCCTreec::tree_decl_common_pt_uid_set;
*swig_size_unit_get = *GCCTreec::tree_decl_common_size_unit_get;
*swig_size_unit_set = *GCCTreec::tree_decl_common_size_unit_set;
*swig_initial_get = *GCCTreec::tree_decl_common_initial_get;
*swig_initial_set = *GCCTreec::tree_decl_common_initial_set;
*swig_attributes_get = *GCCTreec::tree_decl_common_attributes_get;
*swig_attributes_set = *GCCTreec::tree_decl_common_attributes_set;
*swig_abstract_origin_get = *GCCTreec::tree_decl_common_abstract_origin_get;
*swig_abstract_origin_set = *GCCTreec::tree_decl_common_abstract_origin_set;
*swig_lang_specific_get = *GCCTreec::tree_decl_common_lang_specific_get;
*swig_lang_specific_set = *GCCTreec::tree_decl_common_lang_specific_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_decl_common(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_decl_common($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_decl_with_rtl ##############

package GCCTree::tree_decl_with_rtl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_decl_with_rtl_common_get;
*swig_common_set = *GCCTreec::tree_decl_with_rtl_common_set;
*swig_rtl_get = *GCCTreec::tree_decl_with_rtl_rtl_get;
*swig_rtl_set = *GCCTreec::tree_decl_with_rtl_rtl_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_decl_with_rtl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_decl_with_rtl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_field_decl ##############

package GCCTree::tree_field_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_field_decl_common_get;
*swig_common_set = *GCCTreec::tree_field_decl_common_set;
*swig_offset_get = *GCCTreec::tree_field_decl_offset_get;
*swig_offset_set = *GCCTreec::tree_field_decl_offset_set;
*swig_bit_field_type_get = *GCCTreec::tree_field_decl_bit_field_type_get;
*swig_bit_field_type_set = *GCCTreec::tree_field_decl_bit_field_type_set;
*swig_qualifier_get = *GCCTreec::tree_field_decl_qualifier_get;
*swig_qualifier_set = *GCCTreec::tree_field_decl_qualifier_set;
*swig_bit_offset_get = *GCCTreec::tree_field_decl_bit_offset_get;
*swig_bit_offset_set = *GCCTreec::tree_field_decl_bit_offset_set;
*swig_fcontext_get = *GCCTreec::tree_field_decl_fcontext_get;
*swig_fcontext_set = *GCCTreec::tree_field_decl_fcontext_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_field_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_field_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_label_decl ##############

package GCCTree::tree_label_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_label_decl_common_get;
*swig_common_set = *GCCTreec::tree_label_decl_common_set;
*swig_label_decl_uid_get = *GCCTreec::tree_label_decl_label_decl_uid_get;
*swig_label_decl_uid_set = *GCCTreec::tree_label_decl_label_decl_uid_set;
*swig_eh_landing_pad_nr_get = *GCCTreec::tree_label_decl_eh_landing_pad_nr_get;
*swig_eh_landing_pad_nr_set = *GCCTreec::tree_label_decl_eh_landing_pad_nr_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_label_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_label_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_result_decl ##############

package GCCTree::tree_result_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_result_decl_common_get;
*swig_common_set = *GCCTreec::tree_result_decl_common_set;
*swig_ann_get = *GCCTreec::tree_result_decl_ann_get;
*swig_ann_set = *GCCTreec::tree_result_decl_ann_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_result_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_result_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_const_decl ##############

package GCCTree::tree_const_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_const_decl_common_get;
*swig_common_set = *GCCTreec::tree_const_decl_common_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_const_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_const_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_parm_decl ##############

package GCCTree::tree_parm_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_parm_decl_common_get;
*swig_common_set = *GCCTreec::tree_parm_decl_common_set;
*swig_incoming_rtl_get = *GCCTreec::tree_parm_decl_incoming_rtl_get;
*swig_incoming_rtl_set = *GCCTreec::tree_parm_decl_incoming_rtl_set;
*swig_ann_get = *GCCTreec::tree_parm_decl_ann_get;
*swig_ann_set = *GCCTreec::tree_parm_decl_ann_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_parm_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_parm_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_decl_with_vis ##############

package GCCTree::tree_decl_with_vis;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_decl_with_vis_common_get;
*swig_common_set = *GCCTreec::tree_decl_with_vis_common_set;
*swig_assembler_name_get = *GCCTreec::tree_decl_with_vis_assembler_name_get;
*swig_assembler_name_set = *GCCTreec::tree_decl_with_vis_assembler_name_set;
*swig_section_name_get = *GCCTreec::tree_decl_with_vis_section_name_get;
*swig_section_name_set = *GCCTreec::tree_decl_with_vis_section_name_set;
*swig_comdat_group_get = *GCCTreec::tree_decl_with_vis_comdat_group_get;
*swig_comdat_group_set = *GCCTreec::tree_decl_with_vis_comdat_group_set;
*swig_defer_output_get = *GCCTreec::tree_decl_with_vis_defer_output_get;
*swig_defer_output_set = *GCCTreec::tree_decl_with_vis_defer_output_set;
*swig_hard_register_get = *GCCTreec::tree_decl_with_vis_hard_register_get;
*swig_hard_register_set = *GCCTreec::tree_decl_with_vis_hard_register_set;
*swig_thread_local_get = *GCCTreec::tree_decl_with_vis_thread_local_get;
*swig_thread_local_set = *GCCTreec::tree_decl_with_vis_thread_local_set;
*swig_common_flag_get = *GCCTreec::tree_decl_with_vis_common_flag_get;
*swig_common_flag_set = *GCCTreec::tree_decl_with_vis_common_flag_set;
*swig_in_text_section_get = *GCCTreec::tree_decl_with_vis_in_text_section_get;
*swig_in_text_section_set = *GCCTreec::tree_decl_with_vis_in_text_section_set;
*swig_in_constant_pool_get = *GCCTreec::tree_decl_with_vis_in_constant_pool_get;
*swig_in_constant_pool_set = *GCCTreec::tree_decl_with_vis_in_constant_pool_set;
*swig_dllimport_flag_get = *GCCTreec::tree_decl_with_vis_dllimport_flag_get;
*swig_dllimport_flag_set = *GCCTreec::tree_decl_with_vis_dllimport_flag_set;
*swig_weak_flag_get = *GCCTreec::tree_decl_with_vis_weak_flag_get;
*swig_weak_flag_set = *GCCTreec::tree_decl_with_vis_weak_flag_set;
*swig_seen_in_bind_expr_get = *GCCTreec::tree_decl_with_vis_seen_in_bind_expr_get;
*swig_seen_in_bind_expr_set = *GCCTreec::tree_decl_with_vis_seen_in_bind_expr_set;
*swig_comdat_flag_get = *GCCTreec::tree_decl_with_vis_comdat_flag_get;
*swig_comdat_flag_set = *GCCTreec::tree_decl_with_vis_comdat_flag_set;
*swig_visibility_get = *GCCTreec::tree_decl_with_vis_visibility_get;
*swig_visibility_set = *GCCTreec::tree_decl_with_vis_visibility_set;
*swig_visibility_specified_get = *GCCTreec::tree_decl_with_vis_visibility_specified_get;
*swig_visibility_specified_set = *GCCTreec::tree_decl_with_vis_visibility_specified_set;
*swig_tls_model_get = *GCCTreec::tree_decl_with_vis_tls_model_get;
*swig_tls_model_set = *GCCTreec::tree_decl_with_vis_tls_model_set;
*swig_init_priority_p_get = *GCCTreec::tree_decl_with_vis_init_priority_p_get;
*swig_init_priority_p_set = *GCCTreec::tree_decl_with_vis_init_priority_p_set;
*swig_shadowed_for_var_p_get = *GCCTreec::tree_decl_with_vis_shadowed_for_var_p_get;
*swig_shadowed_for_var_p_set = *GCCTreec::tree_decl_with_vis_shadowed_for_var_p_set;
*swig_implicit_section_name_p_get = *GCCTreec::tree_decl_with_vis_implicit_section_name_p_get;
*swig_implicit_section_name_p_set = *GCCTreec::tree_decl_with_vis_implicit_section_name_p_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_decl_with_vis(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_decl_with_vis($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_var_decl ##############

package GCCTree::tree_var_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_var_decl_common_get;
*swig_common_set = *GCCTreec::tree_var_decl_common_set;
*swig_ann_get = *GCCTreec::tree_var_decl_ann_get;
*swig_ann_set = *GCCTreec::tree_var_decl_ann_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_var_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_var_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_decl_non_common ##############

package GCCTree::tree_decl_non_common;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_decl_non_common_common_get;
*swig_common_set = *GCCTreec::tree_decl_non_common_common_set;
*swig_saved_tree_get = *GCCTreec::tree_decl_non_common_saved_tree_get;
*swig_saved_tree_set = *GCCTreec::tree_decl_non_common_saved_tree_set;
*swig_arguments_get = *GCCTreec::tree_decl_non_common_arguments_get;
*swig_arguments_set = *GCCTreec::tree_decl_non_common_arguments_set;
*swig_result_get = *GCCTreec::tree_decl_non_common_result_get;
*swig_result_set = *GCCTreec::tree_decl_non_common_result_set;
*swig_vindex_get = *GCCTreec::tree_decl_non_common_vindex_get;
*swig_vindex_set = *GCCTreec::tree_decl_non_common_vindex_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_decl_non_common(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_decl_non_common($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_function_decl ##############

package GCCTree::tree_function_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_function_decl_common_get;
*swig_common_set = *GCCTreec::tree_function_decl_common_set;
*swig_f_get = *GCCTreec::tree_function_decl_f_get;
*swig_f_set = *GCCTreec::tree_function_decl_f_set;
*swig_personality_get = *GCCTreec::tree_function_decl_personality_get;
*swig_personality_set = *GCCTreec::tree_function_decl_personality_set;
*swig_function_specific_target_get = *GCCTreec::tree_function_decl_function_specific_target_get;
*swig_function_specific_target_set = *GCCTreec::tree_function_decl_function_specific_target_set;
*swig_function_specific_optimization_get = *GCCTreec::tree_function_decl_function_specific_optimization_get;
*swig_function_specific_optimization_set = *GCCTreec::tree_function_decl_function_specific_optimization_set;
*swig_function_code_get = *GCCTreec::tree_function_decl_function_code_get;
*swig_function_code_set = *GCCTreec::tree_function_decl_function_code_set;
*swig_built_in_class_get = *GCCTreec::tree_function_decl_built_in_class_get;
*swig_built_in_class_set = *GCCTreec::tree_function_decl_built_in_class_set;
*swig_static_ctor_flag_get = *GCCTreec::tree_function_decl_static_ctor_flag_get;
*swig_static_ctor_flag_set = *GCCTreec::tree_function_decl_static_ctor_flag_set;
*swig_static_dtor_flag_get = *GCCTreec::tree_function_decl_static_dtor_flag_get;
*swig_static_dtor_flag_set = *GCCTreec::tree_function_decl_static_dtor_flag_set;
*swig_uninlinable_get = *GCCTreec::tree_function_decl_uninlinable_get;
*swig_uninlinable_set = *GCCTreec::tree_function_decl_uninlinable_set;
*swig_possibly_inlined_get = *GCCTreec::tree_function_decl_possibly_inlined_get;
*swig_possibly_inlined_set = *GCCTreec::tree_function_decl_possibly_inlined_set;
*swig_novops_flag_get = *GCCTreec::tree_function_decl_novops_flag_get;
*swig_novops_flag_set = *GCCTreec::tree_function_decl_novops_flag_set;
*swig_returns_twice_flag_get = *GCCTreec::tree_function_decl_returns_twice_flag_get;
*swig_returns_twice_flag_set = *GCCTreec::tree_function_decl_returns_twice_flag_set;
*swig_malloc_flag_get = *GCCTreec::tree_function_decl_malloc_flag_get;
*swig_malloc_flag_set = *GCCTreec::tree_function_decl_malloc_flag_set;
*swig_operator_new_flag_get = *GCCTreec::tree_function_decl_operator_new_flag_get;
*swig_operator_new_flag_set = *GCCTreec::tree_function_decl_operator_new_flag_set;
*swig_declared_inline_flag_get = *GCCTreec::tree_function_decl_declared_inline_flag_get;
*swig_declared_inline_flag_set = *GCCTreec::tree_function_decl_declared_inline_flag_set;
*swig_regdecl_flag_get = *GCCTreec::tree_function_decl_regdecl_flag_get;
*swig_regdecl_flag_set = *GCCTreec::tree_function_decl_regdecl_flag_set;
*swig_no_inline_warning_flag_get = *GCCTreec::tree_function_decl_no_inline_warning_flag_get;
*swig_no_inline_warning_flag_set = *GCCTreec::tree_function_decl_no_inline_warning_flag_set;
*swig_no_instrument_function_entry_exit_get = *GCCTreec::tree_function_decl_no_instrument_function_entry_exit_get;
*swig_no_instrument_function_entry_exit_set = *GCCTreec::tree_function_decl_no_instrument_function_entry_exit_set;
*swig_no_limit_stack_get = *GCCTreec::tree_function_decl_no_limit_stack_get;
*swig_no_limit_stack_set = *GCCTreec::tree_function_decl_no_limit_stack_set;
*swig_disregard_inline_limits_get = *GCCTreec::tree_function_decl_disregard_inline_limits_get;
*swig_disregard_inline_limits_set = *GCCTreec::tree_function_decl_disregard_inline_limits_set;
*swig_pure_flag_get = *GCCTreec::tree_function_decl_pure_flag_get;
*swig_pure_flag_set = *GCCTreec::tree_function_decl_pure_flag_set;
*swig_looping_const_or_pure_flag_get = *GCCTreec::tree_function_decl_looping_const_or_pure_flag_get;
*swig_looping_const_or_pure_flag_set = *GCCTreec::tree_function_decl_looping_const_or_pure_flag_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_function_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_function_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_translation_unit_decl ##############

package GCCTree::tree_translation_unit_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_translation_unit_decl_common_get;
*swig_common_set = *GCCTreec::tree_translation_unit_decl_common_set;
*swig_language_get = *GCCTreec::tree_translation_unit_decl_language_get;
*swig_language_set = *GCCTreec::tree_translation_unit_decl_language_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_translation_unit_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_translation_unit_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_type_decl ##############

package GCCTree::tree_type_decl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_type_decl_common_get;
*swig_common_set = *GCCTreec::tree_type_decl_common_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_type_decl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_type_decl($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_statement_list_node ##############

package GCCTree::tree_statement_list_node;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_prev_get = *GCCTreec::tree_statement_list_node_prev_get;
*swig_prev_set = *GCCTreec::tree_statement_list_node_prev_set;
*swig_next_get = *GCCTreec::tree_statement_list_node_next_get;
*swig_next_set = *GCCTreec::tree_statement_list_node_next_set;
*swig_stmt_get = *GCCTreec::tree_statement_list_node_stmt_get;
*swig_stmt_set = *GCCTreec::tree_statement_list_node_stmt_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_statement_list_node(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_statement_list_node($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_statement_list ##############

package GCCTree::tree_statement_list;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_statement_list_common_get;
*swig_common_set = *GCCTreec::tree_statement_list_common_set;
*swig_head_get = *GCCTreec::tree_statement_list_head_get;
*swig_head_set = *GCCTreec::tree_statement_list_head_set;
*swig_tail_get = *GCCTreec::tree_statement_list_tail_get;
*swig_tail_set = *GCCTreec::tree_statement_list_tail_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_statement_list(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_statement_list($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_optimization_option ##############

package GCCTree::tree_optimization_option;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_optimization_option_common_get;
*swig_common_set = *GCCTreec::tree_optimization_option_common_set;
*swig_opts_get = *GCCTreec::tree_optimization_option_opts_get;
*swig_opts_set = *GCCTreec::tree_optimization_option_opts_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_optimization_option(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_optimization_option($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_target_option ##############

package GCCTree::tree_target_option;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_common_get = *GCCTreec::tree_target_option_common_get;
*swig_common_set = *GCCTreec::tree_target_option_common_set;
*swig_opts_get = *GCCTreec::tree_target_option_opts_get;
*swig_opts_set = *GCCTreec::tree_target_option_opts_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_target_option(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_target_option($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::tree_node ##############

package GCCTree::tree_node;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_base_get = *GCCTreec::tree_node_base_get;
*swig_base_set = *GCCTreec::tree_node_base_set;
*swig_common_get = *GCCTreec::tree_node_common_get;
*swig_common_set = *GCCTreec::tree_node_common_set;
*swig_int_cst_get = *GCCTreec::tree_node_int_cst_get;
*swig_int_cst_set = *GCCTreec::tree_node_int_cst_set;
*swig_real_cst_get = *GCCTreec::tree_node_real_cst_get;
*swig_real_cst_set = *GCCTreec::tree_node_real_cst_set;
*swig_fixed_cst_get = *GCCTreec::tree_node_fixed_cst_get;
*swig_fixed_cst_set = *GCCTreec::tree_node_fixed_cst_set;
*swig_vector_get = *GCCTreec::tree_node_vector_get;
*swig_vector_set = *GCCTreec::tree_node_vector_set;
*swig_string_get = *GCCTreec::tree_node_string_get;
*swig_string_set = *GCCTreec::tree_node_string_set;
*swig_identifier_get = *GCCTreec::tree_node_identifier_get;
*swig_identifier_set = *GCCTreec::tree_node_identifier_set;
*swig_decl_minimal_get = *GCCTreec::tree_node_decl_minimal_get;
*swig_decl_minimal_set = *GCCTreec::tree_node_decl_minimal_set;
*swig_decl_common_get = *GCCTreec::tree_node_decl_common_get;
*swig_decl_common_set = *GCCTreec::tree_node_decl_common_set;
*swig_decl_with_rtl_get = *GCCTreec::tree_node_decl_with_rtl_get;
*swig_decl_with_rtl_set = *GCCTreec::tree_node_decl_with_rtl_set;
*swig_decl_non_common_get = *GCCTreec::tree_node_decl_non_common_get;
*swig_decl_non_common_set = *GCCTreec::tree_node_decl_non_common_set;
*swig_parm_decl_get = *GCCTreec::tree_node_parm_decl_get;
*swig_parm_decl_set = *GCCTreec::tree_node_parm_decl_set;
*swig_decl_with_vis_get = *GCCTreec::tree_node_decl_with_vis_get;
*swig_decl_with_vis_set = *GCCTreec::tree_node_decl_with_vis_set;
*swig_var_decl_get = *GCCTreec::tree_node_var_decl_get;
*swig_var_decl_set = *GCCTreec::tree_node_var_decl_set;
*swig_field_decl_get = *GCCTreec::tree_node_field_decl_get;
*swig_field_decl_set = *GCCTreec::tree_node_field_decl_set;
*swig_label_decl_get = *GCCTreec::tree_node_label_decl_get;
*swig_label_decl_set = *GCCTreec::tree_node_label_decl_set;
*swig_result_decl_get = *GCCTreec::tree_node_result_decl_get;
*swig_result_decl_set = *GCCTreec::tree_node_result_decl_set;
*swig_const_decl_get = *GCCTreec::tree_node_const_decl_get;
*swig_const_decl_set = *GCCTreec::tree_node_const_decl_set;
*swig_type_decl_get = *GCCTreec::tree_node_type_decl_get;
*swig_type_decl_set = *GCCTreec::tree_node_type_decl_set;
*swig_function_decl_get = *GCCTreec::tree_node_function_decl_get;
*swig_function_decl_set = *GCCTreec::tree_node_function_decl_set;
*swig_translation_unit_decl_get = *GCCTreec::tree_node_translation_unit_decl_get;
*swig_translation_unit_decl_set = *GCCTreec::tree_node_translation_unit_decl_set;
*swig_type_get = *GCCTreec::tree_node_type_get;
*swig_type_set = *GCCTreec::tree_node_type_set;
*swig_list_get = *GCCTreec::tree_node_list_get;
*swig_list_set = *GCCTreec::tree_node_list_set;
*swig_vec_get = *GCCTreec::tree_node_vec_get;
*swig_vec_set = *GCCTreec::tree_node_vec_set;
*swig_exp_get = *GCCTreec::tree_node_exp_get;
*swig_exp_set = *GCCTreec::tree_node_exp_set;
*swig_ssa_name_get = *GCCTreec::tree_node_ssa_name_get;
*swig_ssa_name_set = *GCCTreec::tree_node_ssa_name_set;
*swig_block_get = *GCCTreec::tree_node_block_get;
*swig_block_set = *GCCTreec::tree_node_block_set;
*swig_binfo_get = *GCCTreec::tree_node_binfo_get;
*swig_binfo_set = *GCCTreec::tree_node_binfo_set;
*swig_stmt_list_get = *GCCTreec::tree_node_stmt_list_get;
*swig_stmt_list_set = *GCCTreec::tree_node_stmt_list_set;
*swig_constructor_get = *GCCTreec::tree_node_constructor_get;
*swig_constructor_set = *GCCTreec::tree_node_constructor_set;
*swig_omp_clause_get = *GCCTreec::tree_node_omp_clause_get;
*swig_omp_clause_set = *GCCTreec::tree_node_omp_clause_set;
*swig_optimization_get = *GCCTreec::tree_node_optimization_get;
*swig_optimization_set = *GCCTreec::tree_node_optimization_set;
*swig_target_option_get = *GCCTreec::tree_node_target_option_get;
*swig_target_option_set = *GCCTreec::tree_node_target_option_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_tree_node(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_tree_node($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::attribute_spec ##############

package GCCTree::attribute_spec;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *GCCTreec::attribute_spec_name_get;
*swig_name_set = *GCCTreec::attribute_spec_name_set;
*swig_min_length_get = *GCCTreec::attribute_spec_min_length_get;
*swig_min_length_set = *GCCTreec::attribute_spec_min_length_set;
*swig_max_length_get = *GCCTreec::attribute_spec_max_length_get;
*swig_max_length_set = *GCCTreec::attribute_spec_max_length_set;
*swig_decl_required_get = *GCCTreec::attribute_spec_decl_required_get;
*swig_decl_required_set = *GCCTreec::attribute_spec_decl_required_set;
*swig_type_required_get = *GCCTreec::attribute_spec_type_required_get;
*swig_type_required_set = *GCCTreec::attribute_spec_type_required_set;
*swig_function_type_required_get = *GCCTreec::attribute_spec_function_type_required_get;
*swig_function_type_required_set = *GCCTreec::attribute_spec_function_type_required_set;
*swig_handler_get = *GCCTreec::attribute_spec_handler_get;
*swig_handler_set = *GCCTreec::attribute_spec_handler_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_attribute_spec(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_attribute_spec($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : GCCTree::record_layout_info_s ##############

package GCCTree::record_layout_info_s;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( GCCTree );
%OWNER = ();
%ITERATORS = ();
*swig_t_get = *GCCTreec::record_layout_info_s_t_get;
*swig_t_set = *GCCTreec::record_layout_info_s_t_set;
*swig_offset_get = *GCCTreec::record_layout_info_s_offset_get;
*swig_offset_set = *GCCTreec::record_layout_info_s_offset_set;
*swig_offset_align_get = *GCCTreec::record_layout_info_s_offset_align_get;
*swig_offset_align_set = *GCCTreec::record_layout_info_s_offset_align_set;
*swig_bitpos_get = *GCCTreec::record_layout_info_s_bitpos_get;
*swig_bitpos_set = *GCCTreec::record_layout_info_s_bitpos_set;
*swig_record_align_get = *GCCTreec::record_layout_info_s_record_align_get;
*swig_record_align_set = *GCCTreec::record_layout_info_s_record_align_set;
*swig_unpacked_align_get = *GCCTreec::record_layout_info_s_unpacked_align_get;
*swig_unpacked_align_set = *GCCTreec::record_layout_info_s_unpacked_align_set;
*swig_prev_field_get = *GCCTreec::record_layout_info_s_prev_field_get;
*swig_prev_field_set = *GCCTreec::record_layout_info_s_prev_field_set;
*swig_pending_statics_get = *GCCTreec::record_layout_info_s_pending_statics_get;
*swig_pending_statics_set = *GCCTreec::record_layout_info_s_pending_statics_set;
*swig_remaining_in_alignment_get = *GCCTreec::record_layout_info_s_remaining_in_alignment_get;
*swig_remaining_in_alignment_set = *GCCTreec::record_layout_info_s_remaining_in_alignment_set;
*swig_packed_maybe_necessary_get = *GCCTreec::record_layout_info_s_packed_maybe_necessary_get;
*swig_packed_maybe_necessary_set = *GCCTreec::record_layout_info_s_packed_maybe_necessary_set;
sub new {
    my $pkg = shift;
    my $self = GCCTreec::new_record_layout_info_s(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        GCCTreec::delete_record_layout_info_s($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package GCCTree;

*TS_BASE = *GCCTreec::TS_BASE;
*TS_COMMON = *GCCTreec::TS_COMMON;
*TS_INT_CST = *GCCTreec::TS_INT_CST;
*TS_REAL_CST = *GCCTreec::TS_REAL_CST;
*TS_FIXED_CST = *GCCTreec::TS_FIXED_CST;
*TS_VECTOR = *GCCTreec::TS_VECTOR;
*TS_STRING = *GCCTreec::TS_STRING;
*TS_COMPLEX = *GCCTreec::TS_COMPLEX;
*TS_IDENTIFIER = *GCCTreec::TS_IDENTIFIER;
*TS_DECL_MINIMAL = *GCCTreec::TS_DECL_MINIMAL;
*TS_DECL_COMMON = *GCCTreec::TS_DECL_COMMON;
*TS_DECL_WRTL = *GCCTreec::TS_DECL_WRTL;
*TS_DECL_NON_COMMON = *GCCTreec::TS_DECL_NON_COMMON;
*TS_DECL_WITH_VIS = *GCCTreec::TS_DECL_WITH_VIS;
*TS_FIELD_DECL = *GCCTreec::TS_FIELD_DECL;
*TS_VAR_DECL = *GCCTreec::TS_VAR_DECL;
*TS_PARM_DECL = *GCCTreec::TS_PARM_DECL;
*TS_LABEL_DECL = *GCCTreec::TS_LABEL_DECL;
*TS_RESULT_DECL = *GCCTreec::TS_RESULT_DECL;
*TS_CONST_DECL = *GCCTreec::TS_CONST_DECL;
*TS_TYPE_DECL = *GCCTreec::TS_TYPE_DECL;
*TS_FUNCTION_DECL = *GCCTreec::TS_FUNCTION_DECL;
*TS_TRANSLATION_UNIT_DECL = *GCCTreec::TS_TRANSLATION_UNIT_DECL;
*TS_TYPE = *GCCTreec::TS_TYPE;
*TS_LIST = *GCCTreec::TS_LIST;
*TS_VEC = *GCCTreec::TS_VEC;
*TS_EXP = *GCCTreec::TS_EXP;
*TS_SSA_NAME = *GCCTreec::TS_SSA_NAME;
*TS_BLOCK = *GCCTreec::TS_BLOCK;
*TS_BINFO = *GCCTreec::TS_BINFO;
*TS_STATEMENT_LIST = *GCCTreec::TS_STATEMENT_LIST;
*TS_CONSTRUCTOR = *GCCTreec::TS_CONSTRUCTOR;
*TS_OMP_CLAUSE = *GCCTreec::TS_OMP_CLAUSE;
*TS_OPTIMIZATION = *GCCTreec::TS_OPTIMIZATION;
*TS_TARGET_OPTION = *GCCTreec::TS_TARGET_OPTION;
*LAST_TS_ENUM = *GCCTreec::LAST_TS_ENUM;
*obstack_alloc_failed_handler = *GCCTreec::obstack_alloc_failed_handler;
*obstack_exit_failure = *GCCTreec::obstack_exit_failure;
*HT_NO_INSERT = *GCCTreec::HT_NO_INSERT;
*HT_ALLOC = *GCCTreec::HT_ALLOC;
*OMP_CLAUSE_SCHEDULE_STATIC = *GCCTreec::OMP_CLAUSE_SCHEDULE_STATIC;
*OMP_CLAUSE_SCHEDULE_DYNAMIC = *GCCTreec::OMP_CLAUSE_SCHEDULE_DYNAMIC;
*OMP_CLAUSE_SCHEDULE_GUIDED = *GCCTreec::OMP_CLAUSE_SCHEDULE_GUIDED;
*OMP_CLAUSE_SCHEDULE_AUTO = *GCCTreec::OMP_CLAUSE_SCHEDULE_AUTO;
*OMP_CLAUSE_SCHEDULE_RUNTIME = *GCCTreec::OMP_CLAUSE_SCHEDULE_RUNTIME;
*OMP_CLAUSE_DEFAULT_UNSPECIFIED = *GCCTreec::OMP_CLAUSE_DEFAULT_UNSPECIFIED;
*OMP_CLAUSE_DEFAULT_SHARED = *GCCTreec::OMP_CLAUSE_DEFAULT_SHARED;
*OMP_CLAUSE_DEFAULT_NONE = *GCCTreec::OMP_CLAUSE_DEFAULT_NONE;
*OMP_CLAUSE_DEFAULT_PRIVATE = *GCCTreec::OMP_CLAUSE_DEFAULT_PRIVATE;
*OMP_CLAUSE_DEFAULT_FIRSTPRIVATE = *GCCTreec::OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;
*all_translation_units = *GCCTreec::all_translation_units;
*TI_ERROR_MARK = *GCCTreec::TI_ERROR_MARK;
*TI_INTQI_TYPE = *GCCTreec::TI_INTQI_TYPE;
*TI_INTHI_TYPE = *GCCTreec::TI_INTHI_TYPE;
*TI_INTSI_TYPE = *GCCTreec::TI_INTSI_TYPE;
*TI_INTDI_TYPE = *GCCTreec::TI_INTDI_TYPE;
*TI_INTTI_TYPE = *GCCTreec::TI_INTTI_TYPE;
*TI_UINTQI_TYPE = *GCCTreec::TI_UINTQI_TYPE;
*TI_UINTHI_TYPE = *GCCTreec::TI_UINTHI_TYPE;
*TI_UINTSI_TYPE = *GCCTreec::TI_UINTSI_TYPE;
*TI_UINTDI_TYPE = *GCCTreec::TI_UINTDI_TYPE;
*TI_UINTTI_TYPE = *GCCTreec::TI_UINTTI_TYPE;
*TI_UINT32_TYPE = *GCCTreec::TI_UINT32_TYPE;
*TI_UINT64_TYPE = *GCCTreec::TI_UINT64_TYPE;
*TI_INTEGER_ZERO = *GCCTreec::TI_INTEGER_ZERO;
*TI_INTEGER_ONE = *GCCTreec::TI_INTEGER_ONE;
*TI_INTEGER_THREE = *GCCTreec::TI_INTEGER_THREE;
*TI_INTEGER_MINUS_ONE = *GCCTreec::TI_INTEGER_MINUS_ONE;
*TI_NULL_POINTER = *GCCTreec::TI_NULL_POINTER;
*TI_SIZE_ZERO = *GCCTreec::TI_SIZE_ZERO;
*TI_SIZE_ONE = *GCCTreec::TI_SIZE_ONE;
*TI_BITSIZE_ZERO = *GCCTreec::TI_BITSIZE_ZERO;
*TI_BITSIZE_ONE = *GCCTreec::TI_BITSIZE_ONE;
*TI_BITSIZE_UNIT = *GCCTreec::TI_BITSIZE_UNIT;
*TI_PUBLIC = *GCCTreec::TI_PUBLIC;
*TI_PROTECTED = *GCCTreec::TI_PROTECTED;
*TI_PRIVATE = *GCCTreec::TI_PRIVATE;
*TI_BOOLEAN_FALSE = *GCCTreec::TI_BOOLEAN_FALSE;
*TI_BOOLEAN_TRUE = *GCCTreec::TI_BOOLEAN_TRUE;
*TI_COMPLEX_INTEGER_TYPE = *GCCTreec::TI_COMPLEX_INTEGER_TYPE;
*TI_COMPLEX_FLOAT_TYPE = *GCCTreec::TI_COMPLEX_FLOAT_TYPE;
*TI_COMPLEX_DOUBLE_TYPE = *GCCTreec::TI_COMPLEX_DOUBLE_TYPE;
*TI_COMPLEX_LONG_DOUBLE_TYPE = *GCCTreec::TI_COMPLEX_LONG_DOUBLE_TYPE;
*TI_FLOAT_TYPE = *GCCTreec::TI_FLOAT_TYPE;
*TI_DOUBLE_TYPE = *GCCTreec::TI_DOUBLE_TYPE;
*TI_LONG_DOUBLE_TYPE = *GCCTreec::TI_LONG_DOUBLE_TYPE;
*TI_FLOAT_PTR_TYPE = *GCCTreec::TI_FLOAT_PTR_TYPE;
*TI_DOUBLE_PTR_TYPE = *GCCTreec::TI_DOUBLE_PTR_TYPE;
*TI_LONG_DOUBLE_PTR_TYPE = *GCCTreec::TI_LONG_DOUBLE_PTR_TYPE;
*TI_INTEGER_PTR_TYPE = *GCCTreec::TI_INTEGER_PTR_TYPE;
*TI_VOID_TYPE = *GCCTreec::TI_VOID_TYPE;
*TI_PTR_TYPE = *GCCTreec::TI_PTR_TYPE;
*TI_CONST_PTR_TYPE = *GCCTreec::TI_CONST_PTR_TYPE;
*TI_SIZE_TYPE = *GCCTreec::TI_SIZE_TYPE;
*TI_PID_TYPE = *GCCTreec::TI_PID_TYPE;
*TI_PTRDIFF_TYPE = *GCCTreec::TI_PTRDIFF_TYPE;
*TI_VA_LIST_TYPE = *GCCTreec::TI_VA_LIST_TYPE;
*TI_VA_LIST_GPR_COUNTER_FIELD = *GCCTreec::TI_VA_LIST_GPR_COUNTER_FIELD;
*TI_VA_LIST_FPR_COUNTER_FIELD = *GCCTreec::TI_VA_LIST_FPR_COUNTER_FIELD;
*TI_BOOLEAN_TYPE = *GCCTreec::TI_BOOLEAN_TYPE;
*TI_FILEPTR_TYPE = *GCCTreec::TI_FILEPTR_TYPE;
*TI_DFLOAT32_TYPE = *GCCTreec::TI_DFLOAT32_TYPE;
*TI_DFLOAT64_TYPE = *GCCTreec::TI_DFLOAT64_TYPE;
*TI_DFLOAT128_TYPE = *GCCTreec::TI_DFLOAT128_TYPE;
*TI_DFLOAT32_PTR_TYPE = *GCCTreec::TI_DFLOAT32_PTR_TYPE;
*TI_DFLOAT64_PTR_TYPE = *GCCTreec::TI_DFLOAT64_PTR_TYPE;
*TI_DFLOAT128_PTR_TYPE = *GCCTreec::TI_DFLOAT128_PTR_TYPE;
*TI_VOID_LIST_NODE = *GCCTreec::TI_VOID_LIST_NODE;
*TI_MAIN_IDENTIFIER = *GCCTreec::TI_MAIN_IDENTIFIER;
*TI_SAT_SFRACT_TYPE = *GCCTreec::TI_SAT_SFRACT_TYPE;
*TI_SAT_FRACT_TYPE = *GCCTreec::TI_SAT_FRACT_TYPE;
*TI_SAT_LFRACT_TYPE = *GCCTreec::TI_SAT_LFRACT_TYPE;
*TI_SAT_LLFRACT_TYPE = *GCCTreec::TI_SAT_LLFRACT_TYPE;
*TI_SAT_USFRACT_TYPE = *GCCTreec::TI_SAT_USFRACT_TYPE;
*TI_SAT_UFRACT_TYPE = *GCCTreec::TI_SAT_UFRACT_TYPE;
*TI_SAT_ULFRACT_TYPE = *GCCTreec::TI_SAT_ULFRACT_TYPE;
*TI_SAT_ULLFRACT_TYPE = *GCCTreec::TI_SAT_ULLFRACT_TYPE;
*TI_SFRACT_TYPE = *GCCTreec::TI_SFRACT_TYPE;
*TI_FRACT_TYPE = *GCCTreec::TI_FRACT_TYPE;
*TI_LFRACT_TYPE = *GCCTreec::TI_LFRACT_TYPE;
*TI_LLFRACT_TYPE = *GCCTreec::TI_LLFRACT_TYPE;
*TI_USFRACT_TYPE = *GCCTreec::TI_USFRACT_TYPE;
*TI_UFRACT_TYPE = *GCCTreec::TI_UFRACT_TYPE;
*TI_ULFRACT_TYPE = *GCCTreec::TI_ULFRACT_TYPE;
*TI_ULLFRACT_TYPE = *GCCTreec::TI_ULLFRACT_TYPE;
*TI_SAT_SACCUM_TYPE = *GCCTreec::TI_SAT_SACCUM_TYPE;
*TI_SAT_ACCUM_TYPE = *GCCTreec::TI_SAT_ACCUM_TYPE;
*TI_SAT_LACCUM_TYPE = *GCCTreec::TI_SAT_LACCUM_TYPE;
*TI_SAT_LLACCUM_TYPE = *GCCTreec::TI_SAT_LLACCUM_TYPE;
*TI_SAT_USACCUM_TYPE = *GCCTreec::TI_SAT_USACCUM_TYPE;
*TI_SAT_UACCUM_TYPE = *GCCTreec::TI_SAT_UACCUM_TYPE;
*TI_SAT_ULACCUM_TYPE = *GCCTreec::TI_SAT_ULACCUM_TYPE;
*TI_SAT_ULLACCUM_TYPE = *GCCTreec::TI_SAT_ULLACCUM_TYPE;
*TI_SACCUM_TYPE = *GCCTreec::TI_SACCUM_TYPE;
*TI_ACCUM_TYPE = *GCCTreec::TI_ACCUM_TYPE;
*TI_LACCUM_TYPE = *GCCTreec::TI_LACCUM_TYPE;
*TI_LLACCUM_TYPE = *GCCTreec::TI_LLACCUM_TYPE;
*TI_USACCUM_TYPE = *GCCTreec::TI_USACCUM_TYPE;
*TI_UACCUM_TYPE = *GCCTreec::TI_UACCUM_TYPE;
*TI_ULACCUM_TYPE = *GCCTreec::TI_ULACCUM_TYPE;
*TI_ULLACCUM_TYPE = *GCCTreec::TI_ULLACCUM_TYPE;
*TI_QQ_TYPE = *GCCTreec::TI_QQ_TYPE;
*TI_HQ_TYPE = *GCCTreec::TI_HQ_TYPE;
*TI_SQ_TYPE = *GCCTreec::TI_SQ_TYPE;
*TI_DQ_TYPE = *GCCTreec::TI_DQ_TYPE;
*TI_TQ_TYPE = *GCCTreec::TI_TQ_TYPE;
*TI_UQQ_TYPE = *GCCTreec::TI_UQQ_TYPE;
*TI_UHQ_TYPE = *GCCTreec::TI_UHQ_TYPE;
*TI_USQ_TYPE = *GCCTreec::TI_USQ_TYPE;
*TI_UDQ_TYPE = *GCCTreec::TI_UDQ_TYPE;
*TI_UTQ_TYPE = *GCCTreec::TI_UTQ_TYPE;
*TI_SAT_QQ_TYPE = *GCCTreec::TI_SAT_QQ_TYPE;
*TI_SAT_HQ_TYPE = *GCCTreec::TI_SAT_HQ_TYPE;
*TI_SAT_SQ_TYPE = *GCCTreec::TI_SAT_SQ_TYPE;
*TI_SAT_DQ_TYPE = *GCCTreec::TI_SAT_DQ_TYPE;
*TI_SAT_TQ_TYPE = *GCCTreec::TI_SAT_TQ_TYPE;
*TI_SAT_UQQ_TYPE = *GCCTreec::TI_SAT_UQQ_TYPE;
*TI_SAT_UHQ_TYPE = *GCCTreec::TI_SAT_UHQ_TYPE;
*TI_SAT_USQ_TYPE = *GCCTreec::TI_SAT_USQ_TYPE;
*TI_SAT_UDQ_TYPE = *GCCTreec::TI_SAT_UDQ_TYPE;
*TI_SAT_UTQ_TYPE = *GCCTreec::TI_SAT_UTQ_TYPE;
*TI_HA_TYPE = *GCCTreec::TI_HA_TYPE;
*TI_SA_TYPE = *GCCTreec::TI_SA_TYPE;
*TI_DA_TYPE = *GCCTreec::TI_DA_TYPE;
*TI_TA_TYPE = *GCCTreec::TI_TA_TYPE;
*TI_UHA_TYPE = *GCCTreec::TI_UHA_TYPE;
*TI_USA_TYPE = *GCCTreec::TI_USA_TYPE;
*TI_UDA_TYPE = *GCCTreec::TI_UDA_TYPE;
*TI_UTA_TYPE = *GCCTreec::TI_UTA_TYPE;
*TI_SAT_HA_TYPE = *GCCTreec::TI_SAT_HA_TYPE;
*TI_SAT_SA_TYPE = *GCCTreec::TI_SAT_SA_TYPE;
*TI_SAT_DA_TYPE = *GCCTreec::TI_SAT_DA_TYPE;
*TI_SAT_TA_TYPE = *GCCTreec::TI_SAT_TA_TYPE;
*TI_SAT_UHA_TYPE = *GCCTreec::TI_SAT_UHA_TYPE;
*TI_SAT_USA_TYPE = *GCCTreec::TI_SAT_USA_TYPE;
*TI_SAT_UDA_TYPE = *GCCTreec::TI_SAT_UDA_TYPE;
*TI_SAT_UTA_TYPE = *GCCTreec::TI_SAT_UTA_TYPE;
*TI_OPTIMIZATION_DEFAULT = *GCCTreec::TI_OPTIMIZATION_DEFAULT;
*TI_OPTIMIZATION_CURRENT = *GCCTreec::TI_OPTIMIZATION_CURRENT;
*TI_TARGET_OPTION_DEFAULT = *GCCTreec::TI_TARGET_OPTION_DEFAULT;
*TI_TARGET_OPTION_CURRENT = *GCCTreec::TI_TARGET_OPTION_CURRENT;
*TI_CURRENT_TARGET_PRAGMA = *GCCTreec::TI_CURRENT_TARGET_PRAGMA;
*TI_CURRENT_OPTIMIZE_PRAGMA = *GCCTreec::TI_CURRENT_OPTIMIZE_PRAGMA;
*TI_MAX = *GCCTreec::TI_MAX;
*global_trees = *GCCTreec::global_trees;
*itk_char = *GCCTreec::itk_char;
*itk_signed_char = *GCCTreec::itk_signed_char;
*itk_unsigned_char = *GCCTreec::itk_unsigned_char;
*itk_short = *GCCTreec::itk_short;
*itk_unsigned_short = *GCCTreec::itk_unsigned_short;
*itk_int = *GCCTreec::itk_int;
*itk_unsigned_int = *GCCTreec::itk_unsigned_int;
*itk_long = *GCCTreec::itk_long;
*itk_unsigned_long = *GCCTreec::itk_unsigned_long;
*itk_long_long = *GCCTreec::itk_long_long;
*itk_unsigned_long_long = *GCCTreec::itk_unsigned_long_long;
*itk_int128 = *GCCTreec::itk_int128;
*itk_unsigned_int128 = *GCCTreec::itk_unsigned_int128;
*itk_none = *GCCTreec::itk_none;
*integer_types = *GCCTreec::integer_types;
*ptrmemfunc_vbit_in_pfn = *GCCTreec::ptrmemfunc_vbit_in_pfn;
*ptrmemfunc_vbit_in_delta = *GCCTreec::ptrmemfunc_vbit_in_delta;
*ATTR_FLAG_DECL_NEXT = *GCCTreec::ATTR_FLAG_DECL_NEXT;
*ATTR_FLAG_FUNCTION_NEXT = *GCCTreec::ATTR_FLAG_FUNCTION_NEXT;
*ATTR_FLAG_ARRAY_NEXT = *GCCTreec::ATTR_FLAG_ARRAY_NEXT;
*ATTR_FLAG_TYPE_IN_PLACE = *GCCTreec::ATTR_FLAG_TYPE_IN_PLACE;
*ATTR_FLAG_BUILT_IN = *GCCTreec::ATTR_FLAG_BUILT_IN;
*SIZETYPE = *GCCTreec::SIZETYPE;
*SSIZETYPE = *GCCTreec::SSIZETYPE;
*BITSIZETYPE = *GCCTreec::BITSIZETYPE;
*SBITSIZETYPE = *GCCTreec::SBITSIZETYPE;
*TYPE_KIND_LAST = *GCCTreec::TYPE_KIND_LAST;
*sizetype_tab = *GCCTreec::sizetype_tab;
1;
